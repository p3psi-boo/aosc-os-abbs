From f8bce3d8dafd044f0e854c49d936c108b97f89dd Mon Sep 17 00:00:00 2001
From: Chao Li <lichao@loongson.cn>
Date: Wed, 12 Jun 2024 17:30:22 +0800
Subject: [PATCH 27/43] system: Add the way to IO access via MMIO

Usually, it is access the IO like PCI IO via MMIO on non-X86 ARCHs, so
a method to access IO via MMIO is added.

Signed-off-by: Chao Li <lichao@loongson.cn>
---
 system/mmio.h | 133 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 133 insertions(+)
 create mode 100644 system/mmio.h

diff --git a/system/mmio.h b/system/mmio.h
new file mode 100644
index 0000000..c03b558
--- /dev/null
+++ b/system/mmio.h
@@ -0,0 +1,133 @@
+// SPDX-License-Identifier: GPL-2.0
+#ifndef MMIO_H
+#define MMIO_H
+/**
+ * \file
+ *
+ * Provides macro definitions for the MMIO instructions
+ *
+ * This file is not meant to be obfuscating: it's just complicated
+ * to (a) handle it all in a way that makes gcc able to optimize it
+ * as well as possible and (b) trying to avoid writing the same thing
+ * over and over again with slight variations and possibly making a
+ * mistake somewhere.
+ */
+
+#if defined(__loongarch_lp64)
+static __inline uint8_t mmio_read8(uint8_t *addr)
+{
+    uint8_t val;
+
+    __asm__ __volatile__ (
+        "li.d $t0, 0x28\n\t"
+        "csrwr $t0, 0x0\n\t"
+        "ld.b %0, %1\n\t"
+        "csrwr $t0, 0x0\n\t"
+        : "=r" (val)
+        : "m" (*addr)
+        : "$t0", "memory"
+    );
+    return val;
+}
+
+static __inline uint16_t mmio_read16(uint16_t *addr)
+{
+    uint16_t val;
+
+    __asm__ __volatile__ (
+        "li.d $t0, 0x28\n\t"
+        "csrwr $t0, 0x0\n\t"
+        "ld.h %0, %1\n\t"
+        "csrwr $t0, 0x0\n\t"
+        : "=r" (val)
+        : "m" (*addr)
+        : "$t0", "memory"
+    );
+    return val;
+}
+
+static __inline uint32_t mmio_read32(uint32_t *addr)
+{
+    uint32_t val;
+
+    __asm__ __volatile__ (
+        "li.d $t0, 0x28\n\t"
+        "csrwr $t0, 0x0\n\t"
+        "ld.w %0, %1\n\t"
+        "csrwr $t0, 0x0\n\t"
+        : "=r" (val)
+        : "m" (*addr)
+        : "$t0", "memory"
+    );
+    return val;
+}
+
+static __inline uint64_t mmio_read64(uint64_t *addr)
+{
+    uint64_t val;
+
+    __asm__ __volatile__ (
+        "li.d $t0, 0x28\n\t"
+        "csrwr $t0, 0x0\n\t"
+        "ld.d %0, %1\n\t"
+        "csrwr $t0, 0x0\n\t"
+        : "=r" (val)
+        : "m" (*addr)
+        : "$t0", "memory"
+    );
+    return val;
+}
+
+static __inline void mmio_write8(uint8_t *addr, uint8_t val)
+{
+    __asm__ __volatile__ (
+        "li.d $t0, 0x28\n\t"
+        "csrwr $t0, 0x0\n\t"
+        "st.b %z0, %1\n\t"
+        "csrwr $t0, 0x0\n\t"
+        :
+        : "Jr" (val), "m" (*addr)
+        : "$t0", "memory"
+    );
+}
+
+static __inline void mmio_write16(uint16_t *addr, uint16_t val)
+{
+    __asm__ __volatile__ (
+        "li.d $t0, 0x28\n\t"
+        "csrwr $t0, 0x0\n\t"
+        "st.h %z0, %1\n\t"
+        "csrwr $t0, 0x0\n\t"
+        :
+        : "Jr" (val), "m" (*addr)
+        : "$t0", "memory"
+    );
+}
+
+static __inline void mmio_write32(uint32_t *addr, uint32_t val)
+{
+    __asm__ __volatile__ (
+        "li.d $t0, 0x28\n\t"
+        "csrwr $t0, 0x0\n\t"
+        "st.w %z0, %1\n\t"
+        "csrwr $t0, 0x0\n\t"
+        :
+        : "Jr" (val), "m" (*addr)
+        : "$t0", "memory"
+    );
+}
+
+static __inline void mmio_write64(uint64_t *addr, uint64_t val)
+{
+    __asm__ __volatile__ (
+        "li.d $t0, 0x28\n\t"
+        "csrwr $t0, 0x0\n\t"
+        "st.d %z0, %1\n\t"
+        "csrwr $t0, 0x0\n\t"
+        :
+        : "Jr" (val), "m" (*addr)
+        : "$t0", "memory"
+    );
+}
+#endif
+#endif
-- 
2.43.4

